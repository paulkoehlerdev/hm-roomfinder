// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: repository.sql

package geodataRepository

import (
	"context"
)

const getBuildings = `-- name: GetBuildings :many
select id,
       name,
       attr,
       ST_AsGeoJSON(geom)::jsonb              as geom,
       ST_AsGeoJSON(ST_Envelope(geom))::jsonb as bound
FROM building
`

type GetBuildingsRow struct {
	ID    int64  `json:"id"`
	Name  string `json:"name"`
	Attr  []byte `json:"attr"`
	Geom  []byte `json:"geom"`
	Bound []byte `json:"bound"`
}

func (q *Queries) GetBuildings(ctx context.Context) ([]GetBuildingsRow, error) {
	rows, err := q.db.Query(ctx, getBuildings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBuildingsRow
	for rows.Next() {
		var i GetBuildingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Attr,
			&i.Geom,
			&i.Bound,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoors = `-- name: GetDoors :many
select door.id,
       door.room_a,
       door.room_b,
       door.attr,
       ST_AsGeoJSON(door.geom)::jsonb                             as geom,
       ST_AsGeoJSON(st_buffer(ST_Envelope(door.geom), 20))::jsonb as bound
FROM door
         JOIN room as room_a on door.room_a = room_a.id
         JOIN room as room_b on door.room_b = room_b.id
WHERE room_a.level_id = $1
   OR room_b.level_id = $1
`

type GetDoorsRow struct {
	ID    int64  `json:"id"`
	RoomA int64  `json:"roomA"`
	RoomB int64  `json:"roomB"`
	Attr  []byte `json:"attr"`
	Geom  []byte `json:"geom"`
	Bound []byte `json:"bound"`
}

func (q *Queries) GetDoors(ctx context.Context, levelID int64) ([]GetDoorsRow, error) {
	rows, err := q.db.Query(ctx, getDoors, levelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDoorsRow
	for rows.Next() {
		var i GetDoorsRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomA,
			&i.RoomB,
			&i.Attr,
			&i.Geom,
			&i.Bound,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLevels = `-- name: GetLevels :many
select id,
       name,
       building_id,
       attr,
       ST_AsGeoJSON(geom)::jsonb              as geom,
       ST_AsGeoJSON(ST_Envelope(geom))::jsonb as bound
FROM level
WHERE building_id = $1
`

type GetLevelsRow struct {
	ID         int64  `json:"id"`
	Name       string `json:"name"`
	BuildingID int64  `json:"buildingId"`
	Attr       []byte `json:"attr"`
	Geom       []byte `json:"geom"`
	Bound      []byte `json:"bound"`
}

func (q *Queries) GetLevels(ctx context.Context, buildingID int64) ([]GetLevelsRow, error) {
	rows, err := q.db.Query(ctx, getLevels, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLevelsRow
	for rows.Next() {
		var i GetLevelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BuildingID,
			&i.Attr,
			&i.Geom,
			&i.Bound,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRooms = `-- name: GetRooms :many
select id,
       name,
       level_id,
       attr,
       ST_AsGeoJSON(geom)::jsonb              as geom,
       ST_AsGeoJSON(ST_Envelope(geom))::jsonb as bound
FROM room
WHERE level_id = $1
`

type GetRoomsRow struct {
	ID      int64  `json:"id"`
	Name    string `json:"name"`
	LevelID int64  `json:"levelId"`
	Attr    []byte `json:"attr"`
	Geom    []byte `json:"geom"`
	Bound   []byte `json:"bound"`
}

func (q *Queries) GetRooms(ctx context.Context, levelID int64) ([]GetRoomsRow, error) {
	rows, err := q.db.Query(ctx, getRooms, levelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomsRow
	for rows.Next() {
		var i GetRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LevelID,
			&i.Attr,
			&i.Geom,
			&i.Bound,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
