// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: repository.sql

package bulkDataRepository

import (
	"context"
)

const clearDocumentIndex = `-- name: ClearDocumentIndex :exec
DELETE
FROM document_index
`

func (q *Queries) ClearDocumentIndex(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearDocumentIndex)
	return err
}

const createDocumentIndexBuilding = `-- name: CreateDocumentIndexBuilding :exec
WITH new_docs AS (
    INSERT INTO document_index SELECT FROM building
        RETURNING id AS doc_id),
     numbered_buildings AS (SELECT id, ROW_NUMBER() OVER () AS row_num
                            FROM building),
     numbered_docs AS (SELECT doc_id, ROW_NUMBER() OVER () AS row_num
                       FROM new_docs)
UPDATE building
SET doc_id = nd.doc_id
FROM numbered_buildings nb
         JOIN numbered_docs nd ON nb.row_num = nd.row_num
WHERE building.id = nb.id
`

func (q *Queries) CreateDocumentIndexBuilding(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createDocumentIndexBuilding)
	return err
}

const createDocumentIndexLevel = `-- name: CreateDocumentIndexLevel :exec
WITH new_docs AS (
    INSERT INTO document_index SELECT FROM level
        RETURNING id AS doc_id),
     numbered_levels AS (SELECT id, ROW_NUMBER() OVER () AS row_num
                         FROM level),
     numbered_docs AS (SELECT doc_id, ROW_NUMBER() OVER () AS row_num
                       FROM new_docs)
UPDATE level
SET doc_id = nd.doc_id
FROM numbered_levels nb
         JOIN numbered_docs nd ON nb.row_num = nd.row_num
WHERE level.id = nb.id
`

func (q *Queries) CreateDocumentIndexLevel(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createDocumentIndexLevel)
	return err
}

const createDocumentIndexRoom = `-- name: CreateDocumentIndexRoom :exec
WITH new_docs AS (
    INSERT INTO document_index SELECT FROM room
        RETURNING id AS doc_id),
     numbered_rooms AS (SELECT id, ROW_NUMBER() OVER () AS row_num
                        FROM room),
     numbered_docs AS (SELECT doc_id, ROW_NUMBER() OVER () AS row_num
                       FROM new_docs)
UPDATE room
SET doc_id = nd.doc_id
FROM numbered_rooms nb
         JOIN numbered_docs nd ON nb.row_num = nd.row_num
WHERE room.id = nb.id
`

func (q *Queries) CreateDocumentIndexRoom(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createDocumentIndexRoom)
	return err
}

const getDocumentInformation = `-- name: GetDocumentInformation :many
SELECT doc_id, name, attr, 'building' as type, ST_AsGeoJSON(st_Centroid(geom))::jsonb as centroid
FROM building
WHERE doc_id IS NOT NULL
UNION
SELECT doc_id, name, attr, 'level' as type, ST_AsGeoJSON(st_Centroid(geom))::jsonb as centroid
FROM level
WHERE doc_id IS NOT NULL
UNION
SELECT doc_id,
       name,
       (attr || json_build_object('level_id', level_id) :: jsonb) as attr,
       'room'                                                     as type,
       ST_AsGeoJSON(st_Centroid(geom))::jsonb                     as centroid
FROM room
WHERE doc_id IS NOT NULL
`

type GetDocumentInformationRow struct {
	DocID    *int64 `json:"docId"`
	Name     string `json:"name"`
	Attr     []byte `json:"attr"`
	Type     string `json:"type"`
	Centroid []byte `json:"centroid"`
}

func (q *Queries) GetDocumentInformation(ctx context.Context) ([]GetDocumentInformationRow, error) {
	rows, err := q.db.Query(ctx, getDocumentInformation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentInformationRow
	for rows.Next() {
		var i GetDocumentInformationRow
		if err := rows.Scan(
			&i.DocID,
			&i.Name,
			&i.Attr,
			&i.Type,
			&i.Centroid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeojsonInformationFor = `-- name: GetGeojsonInformationFor :many
SELECT name,
       attr,
       'building'                             as type,
       ST_AsGeoJSON(geom)::jsonb              as geom,
       ST_AsGeoJSON(ST_Envelope(geom))::jsonb as bound
FROM building
WHERE doc_id = ANY ($1::bigint[])
UNION
SELECT name,
       attr,
       'level'                                as type,
       ST_AsGeoJSON(geom)::jsonb              as geom,
       ST_AsGeoJSON(ST_Envelope(geom))::jsonb as bound
FROM level
WHERE doc_id = ANY ($1::bigint[])
UNION
SELECT name,
       (attr || json_build_object('level_id', level_id) :: jsonb) as attr,
       'room'                                                     as type,
       ST_AsGeoJSON(geom)::jsonb                                  as geom,
       ST_AsGeoJSON(ST_Envelope(geom))::jsonb                     as bound
FROM room
WHERE doc_id = ANY ($1::bigint[])
`

type GetGeojsonInformationForRow struct {
	Name  string `json:"name"`
	Attr  []byte `json:"attr"`
	Type  string `json:"type"`
	Geom  []byte `json:"geom"`
	Bound []byte `json:"bound"`
}

func (q *Queries) GetGeojsonInformationFor(ctx context.Context, dollar_1 []int64) ([]GetGeojsonInformationForRow, error) {
	rows, err := q.db.Query(ctx, getGeojsonInformationFor, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGeojsonInformationForRow
	for rows.Next() {
		var i GetGeojsonInformationForRow
		if err := rows.Scan(
			&i.Name,
			&i.Attr,
			&i.Type,
			&i.Geom,
			&i.Bound,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
